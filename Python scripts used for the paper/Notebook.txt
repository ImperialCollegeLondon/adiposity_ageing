#Initial exploratory data analysis

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

# Load your dataset
file_path = 'C://your_data_path'  # Replace with your file path
data = pd.read_csv(file_path)

# Remove rows with missing values
data_cleaned = data.dropna()

# Directory to save the plots
save_dir = 'C://your_data_path'

# Scatter Plots for each variable against BMI, colored by sex
variables = ['Visceral_adipose_tissue_volume', 'Subcutaneous_fat_body', 
             'Trunk_fat_mass', 'Whole_body_fat_mass', 
             'Total_abdominal_adipose_tissue', 'Muscle_fat_infiltration']
for var in variables:
    sns.scatterplot(x='BMI', y=var, hue='sex_', data=data_cleaned)
    plt.title(f'Scatter Plot of {var} vs BMI')
    plt.savefig(save_dir + f'scatter_{var}_vs_BMI.jpeg')
    plt.show()

# Box Plots for each variable against BMI, colored by sex
for var in variables:
    sns.boxplot(x='BMI', y=var, hue='sex_', data=data_cleaned)
    plt.title(f'Box Plot of {var} vs BMI')
    plt.savefig(save_dir + f'box_{var}_vs_BMI.jpeg')
    plt.show()

# Violin Plots for each variable against BMI, colored by sex
for var in variables:
    sns.violinplot(x='BMI', y=var, hue='sex_', data=data_cleaned)
    plt.title(f'Violin Plot of {var} vs BMI')
    plt.savefig(save_dir + f'violin_{var}_vs_BMI.jpeg')
    plt.show()

# Pair Plot for all variables colored by sex
sns.pairplot(data_cleaned, hue='sex_')
plt.savefig(save_dir + 'pairplot_all_variables.jpeg')
plt.show()

# Heatmap of correlations - only numeric columns
numeric_data = data_cleaned.select_dtypes(include=[float, int])
correlation_matrix = numeric_data.corr()
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')
plt.title('Heatmap of Variable Correlations')
plt.savefig(save_dir + 'heatmap_correlations.jpeg')
plt.show()

# Faceted Plots using Plotly
for var in variables:
    fig = px.scatter(data_cleaned, x='BMI', y=var, facet_col='sex_', trendline='ols')
    fig.write_image(save_dir + f'facet_{var}_vs_BMI.jpeg')
    fig.show()


#Sankey diagram as alternative to alluvial plots

    import plotly.graph_objects as go
    import pandas as pd
    
    Categorise BMI and MRI derived adiposity values.
    
    # Assuming data_for_plot is your DataFrame with the 'BMI Category' and 'MRI adipose tissue' columns
    # Load your data
    data_for_plot = pd.read_csv('C://your_data_path')
    
    # Categorize BMI and MRI
    data_for_plot['BMI Category'] = data_for_plot['BMI'].apply(categorize_bmi)
    data_for_plot['MRI Category'] = data_for_plot['Whole_body_fat_mass'].apply(categorize_mri)
    
    # Convert sex to a readable format (optional)
    data_for_plot['Sex'] = data_for_plot['sex'].map({0: 'Female', 1: 'Male'})
    
    # Group and count the data
    grouped_data = data_for_plot.groupby(['BMI Category', 'Sex', 'MRI Category']).size().reset_index(name='Counts')
    
    # Prepare the source, target, and value lists for the alluvial plot
    source = []
    target = []
    value = []
    
    bmi_categories = grouped_data['BMI Category'].unique()
    sex_categories = grouped_data['Sex'].unique()
    mri_types = grouped_data['MRI Category'].unique()
    
    # Create a mapping of categories to indices
    category_indices = {cat: idx for idx, cat in enumerate(bmi_categories)}
    sex_indices = {sex: idx + len(bmi_categories) for idx, sex in enumerate(sex_categories)}
    mri_indices = {mri: idx + len(bmi_categories) + len(sex_categories) for idx, mri in enumerate(mri_types)}
    
    # Populate the source, target, and value lists
    for _, row in grouped_data.iterrows():
        bmi_idx = category_indices[row['BMI Category']]
        sex_idx = sex_indices[row['Sex']]
        mri_idx = mri_indices[row['MRI Category']]
    
        # First link (BMI to Sex)
        source.append(bmi_idx)
        target.append(sex_idx)
        value.append(row['Counts'])  # Use 'Counts' for the value
    
        # Second link (Sex to MRI)
        source.append(sex_idx)
        target.append(mri_idx)
        value.append(row['Counts'])  # Use 'Counts' for the value again
    
    
    # Create the alluvial plot
    fig = go.Figure(data=[go.Sankey(
        node=dict(
            pad=15,
            thickness=20,
            line=dict(color='black', width=0.5),
            label=list(bmi_categories) + list(sex_categories) + list(mri_types)
        ),
        link=dict(
            source=source,
            target=target,
            value=value
        ))])
    
    # Increase the size of the plot
    fig.update_layout(
        title_text='Alluvial Plot: BMI Categories, Sex Distribution, and MRI Categories',
        font_size=12,
        width=1000,  # Width of the plot
        height=600   # Height of the plot
    )
    
    fig.show()

# Violin Plots for Phenotype Distribution by Ethnicity and Sex

    import pandas as pd
    import seaborn as sns
    import matplotlib.pyplot as plt
    from matplotlib import rcParams
    
    # Set global font properties
    rcParams['font.family'] = 'Arial'
    rcParams['font.size'] = 6
    rcParams['pdf.fonttype'] = 42  # This ensures fonts are stored as text in PDFs, making them editable in Illustrator
    
    # Replace 'path/to/your/dataset.csv' with the actual path to your dataset file
    df = pd.read_csv('C:/your_data_path')
    df = df.dropna()
    
    # Updated function to plot violin plots with custom colors for Sex
    def plot_violin(ax, df, phenotype):
        sns.violinplot(x='Ethnicity', y=phenotype, hue='Sex', data=df, split=True, inner="quart", 
                       palette={"Male": "#00798c", "Female": "#404080"}, ax=ax)
        ax.set_title(f'{phenotype} Distribution by Ethnicity and Sex')
        ax.set_xlabel('Ethnicity')
        ax.set_ylabel(phenotype)
        ax.tick_params(axis='both', which='major', labelsize=6)  # Adjust tick label size if necessary
        ax.legend(title='Sex', loc='upper right', fontsize=6)
    
    # Assuming your data has these phenotypes; adjust as necessary
    phenotypes = ['VAT', 'ASAT', 'TTFM', 'WBFM', 'TAAT', 'MFI']
    
    # Create a grid of plots with 2 columns and 3 rows
    fig, axes = plt.subplots(nrows=3, ncols=2, figsize=(12, 16))
    
    # Plot for each phenotype
    for i, phenotype in enumerate(phenotypes):
        row = i // 2  # Calculate row index
        col = i % 2   # Calculate column index
        plot_violin(axes[row, col], df, phenotype)
    
    plt.tight_layout()
    
    # Save the combined violin plots as a PDF file
    plt.savefig('violin_plots.pdf', format='pdf')
    
    print("Violin plots saved as 'violin_plots.pdf'")
