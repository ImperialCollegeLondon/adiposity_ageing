R - libraries used: 
  library(tidyverse)
  library(Matrix)
  library(lme4)
  library(emmeans)
  library(ISwR)
  library(ggridges)
  library(MatchIt)
  library(dplyr)
  library(jtools)
  library(broom)
  library(forestmangr)
  library(WeightIt)
  library(RNOmni)
  library(ggalluvial)
  library(ggplot2)
  library(magrittr)
  library(purrr)
  library(cowplot)
  library(tidyr)
  library(RNOmni)
  library(gridExtra)
  library(grid)

#Merging two data sets together 

  # Read the CSV file into a data frame called dups.df. The file contains data on diabetes and hypertension.
  # The 'header = TRUE' argument specifies that the first row contains the column names.
  dups.df <- read.csv("your_data_path", header = TRUE)
  
  # Display column names of an undefined data frame 'df_2' (This line seems to be out of order and will cause an error if executed as is.)
  colnames(df_2)
  
  # Create df_1 by selecting the first 3 columns from dups.df
  df_1 = dups.df[, 1:3]
  
  # Create df_2 by selecting from the 4th column to the last column in dups.df
  df_2 = dups.df[, 4:ncol(dups.df)]
  
  # Using the dplyr package to rename the 'your_col_name' column in df_2 to 'merge_name'
  # Note: This step assumes dplyr package is loaded. You should have library(dplyr) at the beginning of your script.
  df_2 = df_2 %>%
    rename(your_col_name = merge_name)
  
  # Merge df_1 and df_2 data frames based on the 'merge_name' column using an inner join.
  # This means only rows with matching 'merge_name' values in both data frames will be included.
  df_merged = inner_join(df_1, df_2, by = "merge_name")
  
  # Create a logical vector (mask) that identifies which rows in dups.df have 'ID' values matching any 'your_col_name' values
  id_mask = dups.df$ID %in% dups.df$your_col_name
  
  # Use the mask to filter rows in dups.df, creating a new data frame temp_df with only the matching rows
  temp_df = dups.df[id_mask, ]
  
  # Attempt to remove columns named 'column1' and 'column2' from dups.df. 
  # Note: This line will not work as intended due to incorrect syntax for removing multiple columns.
  temp_df = dups.df[, colnames(dups.df) != c(column1, column2)]
  
  # Write the merged data frame (df_merged) to a new CSV file.
  # Note: This step assumes the use of the readr package for write_csv. Ensure you have library(readr) at the beginning of your script.
  write_csv(df_merged, "your_data_path")

#Ridgeline Plot Analysis of Adiposity Phenotypes

    # Load dataset from a specified path
    data_ridge <- read.csv("C:/path_to_file/your_data.csv")
    # Remove rows with missing values
    data_ridge <- na.omit(data_ridge)
    # Display column names of the dataset
    colnames(data_ridge)
    
    # Apply a global theme to all plots with a base font size of 6
    theme_set(theme_minimal(base_size = 6))
    
    # Convert dataset from wide to long format, excluding specified columns
    # This prepares the data for ridgeline plots, focusing on selected variables
    your_data_long <- gather(data_ridge, key = "var_1", value = "var_2", -var_3, -var_4, -var_5, -var_6, -var_7, -var_8, -var_9, -var_10)
    
    # Create the first ridgeline plot for adiposity phenotypes
    gg1 <- ggplot(your_data_long, aes(x = var_2, y = var_1, fill = var_5)) +
      geom_density_ridges(alpha = 0.7) +
      scale_fill_manual(values = c("Male" = "#00798c", "Female" = "#404080")) +
      theme_ridges() +
      theme_minimal() +
      labs(title = "Adiposity phenotypes") +
      theme(plot.title = element_text(size = 6))
    print(gg1)
    
    # Prepare data for a second ridgeline plot by excluding different set of variables
    your_data_long_2 <- gather(data_ridge, key = "var_1", value = "var_2", -var_3, -var_4, -var_5, -var_6, -var_7, -var_11, -var_12, -var_13, -var_14, -var_15)
    
    # Create the second ridgeline plot
    gg2 <- ggplot(your_data_long_2, aes(x = var_2, y = var_1, fill = var_5)) +
      geom_density_ridges(alpha = 0.7) +
      scale_fill_manual(values = c("Male" = "#00798c", "Female" = "#404080")) +
      theme_ridges() +
      theme_minimal() +
      labs(title = "BMI and MRI assessed adiposity") +
      theme(plot.title = element_text(size = 6))
    print(gg2)
        
    # Prepare data for a third ridgeline plot, focusing on normalized variables
    your_data_long_3 <- gather(data_ridge, key = "var_1", value = "var_2", -var_3, -var_4, -var_5, -var_6, -var_7, -var_8, -var_9, -var_10)
    # Display column names of the reshaped data frame
    colnames(your_data_long_3)
    
    # Create the third ridgeline plot for normalized adiposity phenotypes
    gg3 <- ggplot(your_data_long_3, aes(x = var_2, y = var_1, fill = var_5)) +
      geom_density_ridges(alpha = 0.7) +
      scale_fill_manual(values = c("Male" = "#00798c", "Female" = "#404080")) +
      theme_ridges() +
      theme_minimal() +
      labs(title = "Adiposity phenotypes (normalized)") +
      theme(plot.title = element_text(size = 6))
    print(gg3)
        
    # Prepare data for the fourth ridgeline plot, excluding a different set of variables
    your_data_long_4 <- gather(data_ridge, key = "var_1", value = "var_2", -var_3, -var_4, -var_5, -var_6, -var_7, -var_11, -var_12, -var_13, -var_14, -var_15)
    # Display column names of the reshaped data frame for the fourth plot
    colnames(your_data_long4)
    
    # Create the fourth ridgeline plot for BMI and MRI assessed adiposity (normalized)
    gg4 <- ggplot(your_data_long_4, aes(x = var_2, y = var_1, fill = var_5)) +
      geom_density_ridges(alpha = 0.7) +
      scale_fill_manual(values = c("Male" = "#00798c", "Female" = "#404080")) +
      theme_ridges() +
      theme_minimal() +
      labs(title = "BMI and MRI assessed adiposity (normalized)") +
      theme(plot.title = element_text(size = 6))
    print(gg4)
        
    # Create the fifth ridgeline plot for android and gynoid adipose tissue deposition
    gg5 <- ggplot(your_data_long_5, aes(x = var_2, y = var_1, fill = var_6)) +
      geom_density_ridges(alpha = 0.7) +
      scale_fill_manual(values = c("Male" = "#00798c", "Female" = "#404080")) +
      theme_ridges() +
      theme_minimal() +
      labs(title = "Android and gynoid adipose tissue deposition") +
      theme(plot.title = element_text(size = 6))
    print(gg5)
    
    # Prepare data for the sixth ridgeline plot
    your_data_long_6 <- gather(data_angy_na, key = "var_1", value = "var_2", -var_6, -var_7)
    # Display column names of the reshaped data frame for the sixth plot
    colnames(your_data_long_6)
    
    # Create the sixth ridgeline plot for normalized android and gynoid adipose tissue deposition
    gg6 <- ggplot(your_data_long_6, aes(x = var_2, y = var_1, fill = var_6)) +
      geom_density_ridges(alpha = 0.7) +
      scale_fill_manual(values = c("Male" = "#00798c", "Female" = "#404080")) +
      theme_ridges() +
      theme_minimal() +
      labs(title = "Android and gynoid adipose tissue deposition (normalized)") +
      theme(plot.title = element_text(size = 6))
    print(gg6)
    
    # Adjust plots to remove legends and blank axis titles, and to customize grid lines and text sizes
    # Detailed customization options are applied to improve visual aesthetics and clarity of the plots
    
    # Combine plots into a grid layout, arranging them in rows and columns
    # The layout includes a top row, middle row, bottom row, and combines them into a final comprehensive plot
    # Each row may include multiple plots, organized for coherent presentation of the study's findings
    
    # The final step prints the combined plot, showcasing the study's results in a visually engaging format
    print(combined_plot)
    
    # Arrange multiple plots in a grid, adjusting the layout to fit all plots cohesively
    combined_plot <- grid.arrange(gg1, gg3, gg2, gg4, gg5, gg6, ncol = 2, nrow = 3)

#Scatter plot grid for adiposity and biomarker phenotypes 

    # Read and prepare your dataset
    df.sc <- read_csv("your data.csv") %>% na.omit()
    
    # Function to create plots for each adiposity feature
    create_adiposity_plots <- function(df, adiposity_features, y_limits, labels) {
      plots <- map2(adiposity_features, y_limits, ~{
        ggplot(df) +
          geom_jitter(aes_string(x = "age_at_mri", y = .x, color = "factor(sex)"), shape = 16, size = 1.5, alpha = 0.1) +
          geom_smooth(aes_string(x = "age_at_mri", y = .x), method = "lm", size = 0.5, color = "black") +
          geom_density2d(aes_string(x = "age_at_mri", y = .x), alpha = 1, color = "black") +
          ylim(.y) +
          labs(x = "Age (years)", y = labels[[.x]], color = "Sex") +
          scale_color_viridis_d() +
          theme_minimal() +
          theme(panel.grid = element_blank(), panel.background = element_blank())
      })
      return(plots)
    }
    
    # Specify adiposity features and limits
    adiposity_features <- c("Visceral_adipose_tissue_volume", "Subcutaneous_fat_body", "Trunk_fat_mass", "Whole_body_fat_mass", "Muscle_fat_infiltration", "Total_abdominal_adipose_tissue_index")
    y_limits <- list(c(0, 15), c(0, 25), c(0, 42), c(0, 80), c(0, 21), c(0, 14))
    labels <- setNames(c("VAT", "ASAT", "TTFM", "WBFM", "MFI", "TAAT"), adiposity_features)
    
    # Create and print adiposity plots
    adiposity_plots <- create_adiposity_plots(df.sc, adiposity_features, y_limits, labels)
    print(adiposity_plots)
    
    # Create a function for biochemical and endocrine biomarker plots if needed, following a similar pattern.
    # Combine plots using patchwork or grid.arrange as needed. For example:
    combined_plot <- reduce(adiposity_plots, `+`) + plot_layout(ncol = 3)
    print(combined_plot)
    
    # Note: Specific details for biochemical_endocrine_biomarkers_m and biochemical_endocrine_biomarkers_f are omitted for brevity.
    # Adapt the create_adiposity_plots function similarly for these datasets.

#Analisys for adiposity phenotype impact on cardiac aging

    # Analyze the effect of adiposity phenotypes, age, age squared, and sex-specific BMI interaction on cardiovascular aging using linear regression
    fitobes <- lm(ca_delta ~ adiposity phenotype of choice + age_at_mri + poly(age_at_mri, 2) + sex_BMI, fat.peri)
    summary(fitobes) # Display summary statistics of the model
    confint(fitobes, level = .95) # Display 95% confidence intervals for model coefficients
    
    # Perform the same analysis focusing only on females
    fitobes_female <- lm(ca_delta ~ poly(age_at_mri, 2) + sex_BMI*BMI, fat.peri) # Interaction term considers sex-specific effect
    summary(fitobes_female) # Summary for female-specific model
    confint(fitobes_female, level = .95) # 95% confidence intervals for female-specific model
    
    # Perform the analysis focusing only on males
    fitobes_male <- lm(ca_delta ~ poly(age_at_mri, 2) + I(1-sex_BMI)*BMI, fat.peri) # Interaction term adjusted for males
    summary(fitobes_male) # Summary for male-specific model
    confint(fitobes_male, level = .95) # 95% confidence intervals for male-specific model
    # Note: Complete analysis sequence for each adiposity phenotype

    # Extracting tidy output with confidence intervals for various models
    out_conf4 <- tidy(fitobes, conf.int = TRUE)
    out_conf4_female <- tidy(fitobes_female, conf.int = TRUE)
    out_conf4_male <- tidy(fitobes_male, conf.int = TRUE)
    
    # Round the coefficient dataframes and remove the intercept row for cleaner output
    lm_model_out4 <- round_df(out_conf4, digits=10)
    lm_model_out4 <- lm_model_out4[2,] # Remove the intercept for overall
    lm_model_out_conf4_female <- round_df(out_conf4_female, digits=10)
    lm_model_out_conf4_female <- lm_model_out_conf4_female[5,] # Remove the intercept for females
    lm_model_out_conf4_male <- round_df(out_conf4_male, digits=10)
    lm_model_out_conf4_male <- lm_model_out_conf4_male[5,] # Remove the intercept for males
    
    # Combine the processed data into intermediate dataframes and assign group labels for overall, female, and male analyses
    lm_intermediate_4 <- rbind(lm_model_out4, lm_model_out_conf4_female, lm_model_out_conf4_male) 
    lm_intermediate_4$group <- c("Overall", "Female", "Male")
    
    # Assuming similar steps were taken for other models (not shown), combine all intermediate dataframes
    lm_intermediate_overall <-  rbind(lm_intermediate_1, lm_intermediate_2, lm_intermediate_3, lm_intermediate_4)
    
    # Clean the 'term' column by removing digits
    lm_intermediate_overall$term <-  str_replace_all(lm_intermediate_overall$term, "[:digit:]", "")
    
#Creating a forest plot

    # 'lm_intermediate_overall' is assumed to be a dataset containing regression analysis results from previous script
    forestlm_ <- ggplot(lm_intermediate_overall, aes(x = term, y = estimate, ymin = conf.low, ymax = conf.high, fill = group, col = group)) + 
      geom_errorbar(linewidth = 0.5, position = position_dodge(width = 0.5), width = 0) + # Draws error bars for confidence intervals
      geom_point(size = 2, shape = 21, colour = "white", stroke = 0.5, position = position_dodge(width = 0.5), na.rm = TRUE) + # Adds the point estimates
      scale_fill_manual(values = c("Female" = "#404080", "Male" = "#00798c", "Overall" = "grey50")) + # Custom colors for the groups
      scale_color_manual(values = c("Female" = "#404080", "Male" = "#00798c", "Overall" = "grey50")) + # Ensures consistency in group coloring
      scale_x_discrete(name = " ") + # Removes x-axis title
      scale_y_continuous(name = "Beta coefficient", limits = c(-1.5, 1.7)) + # Sets y-axis title and limits
      geom_hline(yintercept = 0, linetype = "dashed", color = "black") + # Adds a horizontal line at zero for reference
      coord_flip() + # Flips the coordinates to make it easier to read
      theme(
        legend.position = "none", # Hides the legend
        panel.background = element_blank(), # Removes background
        panel.grid.major = element_blank(), # Removes major grid lines
        panel.grid.minor = element_blank(), # Removes minor grid lines
        axis.text.x = element_text(size=6, color='black'), # Customizes x-axis text
        axis.text.y = element_text(size=6, color='black'), # Customizes y-axis text
        axis.line.x = element_line(size = 0.8, linetype = "solid"), # Customizes x-axis line
        axis.line.y = element_blank(), # Removes y-axis line
        axis.title.x = element_text(size=6, vjust=0.3, face="plain", color = 'black'), # Customizes x-axis title
        axis.title.y = element_text(size=6, face = "plain", vjust=0.9, angle = 90, colour = 'black'), # Customizes y-axis title
        plot.margin = margin(l = 0,r=0) # Adjusts plot margins
      )
    
    # Print the forest plot
    print(forestlm_bysex2)
    
    # Creates a second plot for displaying p-values and confidence intervals next to the forest plot
    # Assumes 'lm_intermediate_overall' dataset and uses the 'term' as x-axis and an arbitrary y-axis position for labels
    p_right <- ggplot(lm_intermediate_overall) +
      geom_text(size = 6 /.pt,
                aes(x=term, y = 1, group=group, label = paste(round(p.value,9), ", ", round(estimate,3)," (", round(conf.low,3), " - ", round(conf.high,3), ") ",  sep = "")),
                hjust = 1, position=position_dodge(width = 0.5)
      ) +
      coord_flip() + # Flips the coordinates to align with the main forest plot
      theme( legend.position = "none", # Hides the legend
             panel.background = element_blank(), # Removes background
             panel.grid.major = element_blank(), # Removes major grid lines
             panel.grid.minor = element_blank(), # Removes minor grid lines
             axis.text.x  = element_text(size=0.005, color='white'), # Makes x-axis text invisible
             axis.text.y  = element_text(size=0.005, color='white'), # Makes y-axis text invisible
             axis.line.x = element_line(size = 0.8, linetype = "solid", color="white"), # Makes x-axis line invisible
             axis.line.y = element_blank(), # Removes y-axis line
             axis.title.x  = element_text(size=0.005, vjust=0.3, face="plain", color = 'white'), # Makes x-axis title invisible
             axis.title.y  = element_text(size=0.005, face = "plain", vjust=0.9, angle = 90, colour = 'white'), # Makes y-axis title invisible
             axis.ticks.x = element_line(color="white"), # Makes x-axis ticks invisible
             axis.ticks.y = element_line(color="white"), # Makes y-axis ticks invisible
             panel.border = element_blank(), # Removes panel border
             panel.spacing = unit(c(0, 0, 0, 0), "null"), # Adjusts panel spacing
             plot.margin = margin(l = 0,r=0) # Adjusts plot margins
    )

    # Adjusts margins for the forest plot to make room for the p-values plot
    forestlm_ <- forestlm_ + 
      theme(plot.margin = margin(l = 5, r = -20, t = 10, b = 10, unit = "pt")) 
    
    # Adjusts margins for the p-values plot to align it properly with the forest plot
    p_right <- p_right + 
      theme(plot.margin = margin(l = -80, r = 80, t = 6, b = 14, unit = "pt"))
    
    # Combines the forest plot and the p-values plot side by side with adjusted widths for each
    grid_name <- plot_grid(forestlm_bysex2, p_right, rel_widths = c(1, 1))

#Alluvial plots. Assuming you have done categirisation for contineous variables. In our approach MRI derived whole body fat mass was categorised accordint to median quantiles for BMI classes lower trhechoald values ('Normal weight', 'Overweight', 'Obese')

    # Read the data
    data_for_plot <- read.csv('C:/path_to_file/your_data.csv')
    # Convert sex to a readable format (optional)
    data_for_plot$Sex <- ifelse(data_for_plot$sex == 0, 'Female', 'Male')
    
    # Group and count the data
    grouped_data <- data_for_plot %>%
      group_by(BMI_Category, Sex, MRI_Category) %>%
      summarise(Counts = n(), .groups = 'drop')
    
    
    theme_set(theme_minimal(base_size = 6))
    
    # Function to create alluvial plot
    create_alluvial_plot <- function(data, title) {
      grouped_data <- data %>%
        group_by(BMI_Category, MRI_Category) %>%
        summarise(Counts = n(), .groups = 'drop')
      
      ggplot(grouped_data,
             aes(axis1 = BMI_Category, axis2 = MRI_Category, y = Counts)) +
        geom_alluvium(aes(fill = BMI_Category)) +
        geom_stratum() +
        geom_text(stat = "stratum", aes(label = after_stat(stratum)), size = 6) +
        theme_minimal() +
        theme(text = element_text(size = 6),
              panel.grid.major = element_blank(),  # Remove major grid lines
              panel.grid.minor = element_blank(),  # Remove minor grid lines
              panel.background = element_blank()) + # Remove panel background
        ggtitle(title)
    }
    
    # Filter data for male and female
    data_male <- data_for_plot[data_for_plot$Sex == 'Male', ]
    data_female <- data_for_plot[data_for_plot$Sex == 'Female', ]
    
    # Create and display the plot for male
    plot_male <- create_alluvial_plot(data_male, "Alluvial Plot for Female Participants")
    print(plot_male)
    
    # Create and display the plot for female
    plot_female <- create_alluvial_plot(data_female, "Alluvial Plot for male Participants")
    print(plot_female)
    
    
    quantiles_info <- data_for_plot %>%
      group_by(BMI_Category) %>%
      summarise(
        Q25 = quantile(Whole_body_fat_mass, 0.25),
        Median = quantile(Whole_body_fat_mass, 0.5),
        Q75 = quantile(Whole_body_fat_mass, 0.75)
      ) %>%
      ungroup()
    
    # Function to create alluvial plot with ordered BMI categories
    create_alluvial_plot <- function(data, title) {
      # Convert BMI_Category to a factor with specified levels
      data$BMI_Category <- factor(data$BMI_Category, levels = c('Normal weight', 'Overweight', 'Obese'))
      
      grouped_data <- data %>%
        group_by(BMI_Category, MRI_Category) %>%
        summarise(Counts = n(), .groups = 'drop')
      
      ggplot(grouped_data,
             aes(axis1 = BMI_Category, axis2 = MRI_Category, y = Counts)) +
        geom_alluvium(aes(fill = BMI_Category)) +
        geom_stratum() +
        geom_text(stat = "stratum", aes(label = after_stat(stratum)), size = 6) +
        theme_minimal() +
        theme(text = element_text(size = 6),
              panel.grid.major = element_blank(),  # Remove major grid lines
              panel.grid.minor = element_blank(),  # Remove minor grid lines
              panel.background = element_blank()) + # Remove panel background
        ggtitle(title)
    }
    
    # Filter data for male and female
    data_male <- data_for_plot[data_for_plot$Sex == 'Male', ]
    data_female <- data_for_plot[data_for_plot$Sex == 'Female', ]
    
    # Create and display the plot for male
    plot_female <- create_alluvial_plot(data_male, "Alluvial Plot for Female Participants")
    print(plot_female)
    
    # Create and display the plot for female
    plot_male <- create_alluvial_plot(data_female, "Alluvial Plot for Male Participants")
    print(plot_male)
    
    # Recalculate grouped data including Counts for plotting
    grouped_data <- data_for_plot %>%
      group_by(Sex, BMI_Category, MRI_Category) %>%
      summarise(Counts = n(), .groups = 'drop')
    
    # Updated function to create alluvial plots with quantiles in titles
    create_alluvial_plot_with_quantiles <- function(grouped_data, sex, quantiles_info) {
      # Filter grouped data for the specified sex
      data_sex <- filter(grouped_data, Sex == sex)
      
      # Dynamically generate title with quantiles info
      title_text <- paste("Alluvial Plot for", sex, "Participants\nQuantiles for Whole Body Fat Mass:",
                          paste(quantiles_info$BMI_Category, 
                                "Q25:", quantiles_info$Q25, 
                                "Median:", quantiles_info$Median, 
                                "Q75:", quantiles_info$Q75, 
                                collapse = " | "))
      
      # Create the plot
      plot <- ggplot(data_sex,
                     aes(axis1 = BMI_Category, axis2 = MRI_Category, y = Counts)) +
        geom_alluvium(aes(fill = BMI_Category)) +
        geom_stratum() +
        geom_text(stat = "stratum", aes(label = after_stat(stratum)), size = 6) +
        theme_minimal() +
        theme(text = element_text(size = 6),
              panel.grid.major = element_blank(),
              panel.grid.minor = element_blank(),
              panel.background = element_blank()) +
        ggtitle(title_text)
      
      return(plot)
    }
    
    # Ensure quantiles_info is calculated as shown previously
    
    # Create and display the plot for male and female, with quantiles in titles
    plot_male_with_quantiles <- create_alluvial_plot_with_quantiles(grouped_data, "Male", quantiles_info)
    plot_female_with_quantiles <- create_alluvial_plot_with_quantiles(grouped_data, "Female", quantiles_info)
    
    print(plot_male_with_quantiles)
    print(plot_female_with_quantiles)
